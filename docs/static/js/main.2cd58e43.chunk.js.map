{"version":3,"sources":["components/AddCategory.js","helpers/getGifs.js","components/GifGriditem.js","components/GifGrid.js","hooks/useFetchGifs.js","GifExpertApp.js","index.js"],"names":["AddCategory","setCategories","useState","inputValue","setInputValue","onSubmit","e","preventDefault","trim","length","cats","type","value","onChange","target","getGifs","category","a","url","encodeURI","fetch","resp","json","data","gifs","map","img","id","title","images","downsized_medium","GifGriditem","className","src","alt","GifGrid","loading","state","setState","useEffect","then","imag","useFetchGifs","GifExpertApp","categories","ReactDOM","render","document","getElementById"],"mappings":"mMAIaA,EAAc,SAAC,GAAqB,IAApBC,EAAmB,EAAnBA,cAEzB,EAAoCC,mBAAS,IAA7C,mBAAOC,EAAP,KAAmBC,EAAnB,KA0BA,OACI,sBAAMC,SAlBY,SAACC,GAInBA,EAAEC,iBAGCJ,EAAWK,OAAOC,OAAQ,IAEzBR,GAAc,SAAAS,GAAI,OAAKP,GAAL,mBAAmBO,OAEzCN,EAAc,MAOd,SAEE,uBACAO,KAAK,OACLC,MAAST,EACTU,SA9BoB,SAACP,GAGvBF,EAAcE,EAAEQ,OAAOF,a,+BCXlBG,EAAO,uCAAG,WAAMC,GAAN,uBAAAC,EAAA,6DAEXC,EAFW,iDAEqCC,UAAUH,GAF/C,+DAKEI,MAAMF,GALR,cAKXG,EALW,gBAMIA,EAAKC,OANT,uBAMVC,EANU,EAMVA,KAEDC,EAAOD,EAAKE,KAAI,SAAAC,GAAQ,IAAD,EACzB,MAAO,CAEHC,GAAGD,EAAIC,GACPC,MAAMF,EAAIE,MACVV,IAAG,UAACQ,EAAIG,cAAL,aAAC,EAAYC,iBAAiBZ,QAbxB,kBAmBVM,GAnBU,4CAAH,sDCGPO,EAAc,SAAC,GAAmB,EAAlBJ,GAAmB,IAAhBC,EAAe,EAAfA,MAAMV,EAAS,EAATA,IAIlC,OACI,sBAAKc,UAAU,yCAAf,UACG,qBAAKC,IAAKf,EAAKgB,IAAKN,IACpB,4BAAIA,QCJFO,EAAU,SAAC,GAAgB,IAAfnB,EAAc,EAAdA,SAGzB,ECA4B,SAACA,GAEzB,MAA0Bd,mBAAS,CAC/BqB,KAAK,GACLa,SAAQ,IAFZ,mBAAOC,EAAP,KAAcC,EAAd,KAoBJ,OAfIC,qBAAW,WAGPxB,EAAQC,GACPwB,MAAM,SAAAC,GAGCH,EAAS,CACLf,KAAKkB,EACLL,SAAQ,SAGrB,CAACpB,IAGDqB,EDtBuBK,CAAa1B,GAA/Ba,EAAZ,EAAON,KAAYa,EAAnB,EAAmBA,QAIf,OACI,qCACA,oBAAIJ,UAAU,oCAAd,SAAmDhB,IAOpDoB,GAAW,mBAAGJ,UAAU,mCAAb,qBAEV,qBAAKA,UAAU,YAAf,SAEYH,EAAOJ,KAAK,SAAAC,GAAG,OACX,aADe,CACd,EAAD,eAEOA,GADAA,EAAIC,aExBtBgB,EAAe,WAKzB,MAAoCzC,mBAAS,CAAC,cAA9C,mBAAO0C,EAAP,KAAmB3C,EAAnB,KAkBC,OACI,qCACC,gDACA,cAAC,EAAD,CAAaA,cAAiBA,IAE9B,uBAOG,6BAEQ2C,EAAWnB,KAAI,SAAAT,GAAQ,OAGrB,aAFC,CAEA,EAAD,CAGAA,SAAUA,GAFLA,Y,MCvC3B6B,IAASC,OACL,cAAC,EAAD,IACFC,SAASC,eAAe,W","file":"static/js/main.2cd58e43.chunk.js","sourcesContent":["import React,{useState} from 'react'\r\nimport PropTypes from 'prop-types'\r\n\r\n//esta funcion es para poder escribir añadirun inputo o caja de texto\r\nexport const AddCategory = ({setCategories}) => {//hacemos la desestructuracion {setCategories} que estaa en el archivo o funcio padre\r\n\r\n    const [inputValue, setInputValue] = useState('')//ejarlo como string vacio \r\n\r\n    const handleInputChange = (e) =>{//para poder cambiar el texto en la caja de texto\r\n        //para que la person escriba algo\r\n        //console.log(e.target.value)\r\n        setInputValue(e.target.value)\r\n\r\n    }\r\n\r\n    const handleSubmit  = (e)=>{\r\n        //esta funcion es para que no se recargue toda la pagina\r\n        //digamos solo el fragmento de la caja de texto al hacer enter\r\n        //le pasamos el onSubmit={handleSubmit} al form\r\n        e.preventDefault()//prevenir eL comportamiiento del formulario\r\n        //console.log('submit echo')\r\n        //VALIDACION en el submit\r\n        if(inputValue.trim().length >2)//si es mayor a dos letras\r\n        {\r\n            setCategories(cats => [inputValue,...cats])\r\n        //colocamos cats => [ 'El perro cobarde',...cats] porque no se tiene acceso  las categorias(el arreglo)\r\n        setInputValue('')//par que no haga un doble posteo a la hora de escribir en la caj de texto  se quita el texto\r\n        }\r\n        \r\n    }\r\n\r\n\r\n    return (\r\n        <form onSubmit={handleSubmit}>\r\n            {/* <h1> {inputValue}</h1>*/}\r\n          <input \r\n          type=\"text\"\r\n          value = {inputValue}\r\n          onChange = { handleInputChange }\r\n          \r\n          />\r\n  {/*si teneos un fragemnto que agrupe todo lo demas en este caso un <form></form> no es necesario poner <></>*/}\r\n        </form>\r\n    )\r\n}\r\n\r\n//para hecer mi funcion del proptypes lo cual debe de ser requerida  en \r\n//<AddCategory setCategories = {setCategories}/> en mi archivo principal\r\n//para que otra gente utilice nuestra funcion o componente con los argumentos que estoy esperando\r\nAddCategory.propTypes ={\r\n    setCategories:PropTypes.func.isRequired\r\n}","export const getGifs = async(category) =>{\r\n    //buscar los endpoints pra consumir el API del GIPHY  en la pagina\r\n      const url = `https://api.giphy.com/v1/gifs/search?q=${encodeURI(category)}&limit=10&api_key=b4BqK3IwDaii8W8ofgf7ZJyybUSBCARy`\r\n      //remplazamos  en el q= por ${encodeURI(category)} le pasamos la category y la funcion encodeURI que sirev por si tiene espacios lo repmplaza\r\n      //ponerle + en los espacios de la url\r\n      const resp = await fetch(url) \r\n      const {data} = await resp.json() //recibimos la respuesta en formato json\r\n  \r\n      const gifs = data.map(img => {//barremos las imagenes\r\n          return {//solo extraemos la informacion o los datos que queremos\r\n              //y retornamos el objeto\r\n              id:img.id,\r\n              title:img.title,\r\n              url:img.images?.downsized_medium.url//ponemos ?(es una condicion) para preguntar que si tiene las imagenes la utilice \r\n          }\r\n      })\r\n      //console.log(gifs)\r\n      //setImages(gifs)//el esatdo sera los gifs que estoy recibiendo\r\n\r\n      return gifs //en ves de regresar setImages(gifs) poruqe no tenemos esa funcion solo retornamos gifs\r\n  }","import React from 'react'\r\n\r\n\r\nexport const GifGriditem = ({id,title,url}) => {//recibimos una imagen(img) o un gif(un props)\r\n // es como si pusieramos en ves de props {id,title,url}\r\n   // console.log(id,title,url)\r\n    \r\n    return (\r\n        <div className=\"card animate__animated animate__fadeIn\">{/*se le pone className en react(ya que class es una palabra reservada en JS) es del css o archivo index.css*/}\r\n           <img src={url} alt={title}/>\r\n           <p>{title}</p>\r\n        </div>\r\n    )\r\n}\r\n","//este sera una coleccion de todos los lementos que coinciden con al categoria\r\nimport React  from 'react'\r\nimport { useFetchGifs } from '../hooks/useFetchGifs'\r\n//import { getGifs } from '../helpers/getGifs'\r\nimport { GifGriditem } from './GifGriditem'\r\n//en esta funcion (GifGrid) necesitamos recibir la categoria y hace runa peticion http\r\nexport const GifGrid = ({category}) => {\r\n //const [count, setCount] = useState(0) solo era un ejemplo para ver los del useEfect con el boton\r\n\r\nconst {data:images,loading} = useFetchGifs(category);\r\n//para renombrar es con dos puntos : y el nombre que le queremos dar (data:images)\r\n\r\n\r\n    return (\r\n        <>\r\n        <h3 className=\"animate__animated animate__fadeIn\">{category}</h3>\r\n        \r\n        {/* aplicamos un ternario \r\n        {loading ? 'Cargando...' : 'Data cargada'}\r\n         {loading && <p>loading</p>} forma corta de ternario\r\n                 */}\r\n\r\n      {loading && <p className=\"animate__animated animate__flash\">Loading</p>}\r\n        \r\n        <div className=\"card-grid\">\r\n                {\r\n                    images.map( img =>(//barremos para  que nos muestre  los id dell img y podemos retornar un objeto\r\n                        <GifGriditem \r\n                          key={img.id}\r\n                          { ...img }//utilizamos el operador spreg,mandamso cada una de las propiedades de las imagenes como una propiedad independiente obtenemos el id,title y el url\r\n                         \r\n                        />\r\n                    ))\r\n                }\r\n         \r\n             </div>\r\n        \r\n            {/*<button onClick={ () => setCount(count+1)}></button> incrementador damos clik y se dispara la peticion http*/}\r\n       \r\n        </>\r\n    )\r\n}\r\n","//al poner o al tener la palbara use en el nombre del archivo le indicamos que es un hook\r\n//todos lo hooks empiezan con use\r\n//los hooks son funciones,funcionan como si fueran funcionals components pueden tenet efectos,usar reducer,cotextos tec.\r\n\r\nimport {useState,useEffect} from 'react'\r\nimport {getGifs} from '../helpers/getGifs'\r\n\r\n//lo que hace es un estado que si lo llamamos nos retorna el objeto\r\n//se encarga de realiazar la peticion automatica cuando  se cargue el componente por primera vez\r\nexport const useFetchGifs = (category) =>{\r\n//cuando se utilice el useFetchGifs se tiene un estado que va estar cargando por defecto\r\n    const [state, setState] = useState({ //el estado inicial va a ser un objeto,un arreglo vacio \r\n        data:[],\r\n        loading:true\r\n    })\r\n\r\n    useEffect( () =>{\r\n        //aqui adentro vamos a ejecutar el cuerpo de mi peticion http\r\n        //para traer las imagenes\r\n        getGifs(category)//esta es la funcion para haccer la peticion    \r\n        .then( imag => {//es como una promesa pero no ponemos el async solo el then\r\n            //traemos las imgenes\r\n                //console.log(imag)\r\n                setState({ //llamaos el setState de arriba\r\n                    data:imag,//la dat serian las imagenes\r\n                    loading:false //seria en false porque ya termina de cargar\r\n                })     \r\n        })\r\n     },[category])\r\n\r\n   \r\nreturn state //recordemos que el state es la data que es un arreglo en true {data:[],loading:true}\r\n\r\n}","import React,{useState} from 'react'\r\nimport { AddCategory } from './components/AddCategory'\r\nimport { GifGrid } from './components/GifGrid'\r\n\r\nexport const GifExpertApp = () => {//esta es nuestra funcion PADRE \r\n\r\n   // const categories = ['One Punch','Dragon Ball','Inuyasha']\r\n \r\n   //la instruccion para ñadir un elemento o fuera de otro archivo es mediante setCategories\r\n   const [categories, setCategories] = useState(['one punch'])\r\n/*\r\n   const handleAdd = () =>{\r\n    //categories.push('El perro cobarde') no se utiliza el push para  insertar otro eleemnto\r\n    //se utiliza el setCategories \r\n    //setCategories('El perro cobarde') asi NO sse agregan los elementos ya que se crea un nuevo estado un string('El perro cobarde')\r\n    //setCategories([...categories,'El perro cobarde'])//asi podemos agregar un nuevo elemento al arreglo\r\n    //hay varias formas de hacerlo en este caso utilizando el operador spred(...)la cual extraemos las categorias\r\n    // y añadimos uno nuevo\r\n    //si queremos que se añada primero  setCategories(['El perro cobarde',...categories])\r\n    //LA OTRA SOLUCION PARA AGREGAR UN ELEMENTO utilizamos un callbak\r\n    setCategories(cats => [ 'El perro cobarde',...cats])\r\n\r\n    //NOTA si incertamos dos veces al dar clik lanzara el error\r\n    //por que se estan duplicando los elemntos('El perro cobarde')\r\n   }\r\n*/\r\n\r\n    return (\r\n        <>\r\n         <h2>Gif Expert App</h2>\r\n         <AddCategory setCategories = {setCategories}/>\r\n         \r\n         <hr/>\r\n             {/*no se puede colocar una estructura ciclcica como el  for,se necesita una expresion que regrese algo\r\n             .Podemos utilizar metodos como el map digamos para barer el arreglo \r\n             El map es como un pequeño ciclo*/}\r\n\r\n            {/*<button onClick={handleAdd} >Agregar</button> */} \r\n           \r\n            <ol>\r\n                {  //el map recibe la categoria y un indice asi (category,i) pero solo necesitamos la categoria\r\n                    categories.map(category => (\r\n                       //  <li key={category}> {category}</li>) \r\n                                           //en el key ponemos el id unico del elemento(category) \r\n                      <GifGrid \r\n                      key={category}//se necesita el key sino llanzara un errrpr\r\n                      //al poner un nombre en el buscador se le va asignando su key o id\r\n                      category={category}\r\n                      />                                           \r\n                    ) ) //lo ponemos en parentesis para decirle que  regresa un obeto                                         \r\n                    \r\n                }\r\n            </ol>\r\n        </>\r\n    )\r\n}\r\n\r\n \r\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { GifExpertApp } from './GifExpertApp';\n\nimport './index.css';\n\nReactDOM.render(\n    <GifExpertApp />,\n  document.getElementById('root')\n);\n\n//https://es.reactjs.org/docs/faq-structure.html\n//checar urls\n//https://hackernoon.com/structuring-projects-and-naming-components-in-react-1261b6e18d76\n\n//los custom hook es una forma de extraer logica de un compenente que quiero utilizar\n//y extraerla de tal manera que se a sencillo utilizarla nuevamente\n"],"sourceRoot":""}